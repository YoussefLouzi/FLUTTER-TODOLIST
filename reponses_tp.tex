\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{url}

\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textcolor{gray}{\textbf{TP3 - Flutter TodoList}}}
\fancyhead[R]{\textcolor{gray}{\thepage}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{gray}\leaders\hrule height \headrulewidth\hfill}}

\definecolor{darkblue}{RGB}{25, 25, 112}
\definecolor{lightgray}{RGB}{128, 128, 128}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{4cm}
    
    {\Huge\color{darkblue}\textbf{TP3}}
    
    \vspace{0.5cm}
    {\LARGE Application TodoList Flutter}
    
    \vspace{3cm}
    
    \begin{tabular}{ll}
        \textbf{Étudiant :} & Youssef LOUZI \\[0.5cm]
        \textbf{Date :} & \today \\[0.5cm]
        \textbf{Module :} & Développement Mobile \\[0.5cm]
        \textbf{Repository :} & \url{https://github.com/YoussefLouzi/FLUTTER-TODOLIST}
    \end{tabular}
    
    \vfill
    
    \rule{\textwidth}{0.5pt}
    
\end{titlepage}

\newpage

\section*{Réponses aux Questions}

\subsection*{1. Rôle de main() et runApp()}
La fonction main() est le point de départ de mon app Flutter. C'est la première chose qui s'exécute quand je lance l'application. runApp() prend mon widget principal et l'affiche à l'écran.

\subsection*{2. Que représente MaterialApp}
MaterialApp c'est le conteneur principal de mon app. Il me donne le style Material Design de Google avec tous les composants qui vont bien ensemble. Il gère aussi la navigation et les thèmes.

\subsection*{3. Que représente home}
home c'est la première page que l'utilisateur voit quand il ouvre l'app. C'est mon écran d'accueil.

\subsection*{4. Pourquoi Tasks hérite de StatefulWidget}
Parce que ma liste de tâches va changer ! L'utilisateur va ajouter, supprimer des tâches. StatefulWidget me permet de mettre à jour l'affichage quand les données changent.

\subsection*{5. Rôle de createState()}
createState() crée l'objet qui va gérer l'état de mon widget. Elle retourne une instance de \_TasksState qui contient toute la logique et les données qui peuvent changer.

\subsection*{6. Pourquoi créer \_TasksState}
Flutter sépare les widgets (immutables) de leur état (mutable). \_TasksState contient mes variables qui changent, comme la liste des tâches. Le \_ la rend privée au fichier.

\subsection*{7. Rôle de build()}
build() construit l'interface visuelle. Elle retourne un Widget qui décrit à quoi ressemble mon écran. Flutter l'appelle automatiquement quand il faut redessiner.

\subsection*{8. À quoi sert flutter pub add uuid}
Cette commande ajoute le package uuid à mon projet. UUID génère des identifiants uniques pour mes tâches, comme ça chaque tâche a son propre ID unique.

\subsection*{9. Pourquoi les propriétés Task sont final}
final empêche de modifier les propriétés après création. C'est plus sûr et ça évite les bugs. Si je veux changer une tâche, je crée une nouvelle instance.

\subsection*{10. Pourquoi TasksList est StatelessWidget}
TasksList ne fait qu'afficher les données qu'on lui donne. Elle ne gère pas d'état interne, juste l'affichage. Plus simple et plus performant.

\subsection*{11. À quoi sert la flèche $\Rightarrow$}
C'est une syntaxe courte pour les fonctions simples. Au lieu d'écrire \{return ...\}, j'écris juste $\Rightarrow$ ... C'est plus compact.

\subsection*{12. Code sans $\Rightarrow$}
\begin{verbatim}
itemBuilder: (ctx, index) {
  return Text(tasks[index].title);
}
\end{verbatim}
C'est plus long mais parfois plus clair pour du code complexe.

\subsection*{13. À quoi sert Card}
Card donne un joli style à mes éléments avec des ombres et des coins arrondis. Ça fait plus professionnel et ça sépare visuellement chaque tâche.

\subsection*{14. Rôle de ThemeData et AppBarTheme}
ThemeData définit l'apparence globale de mon app (couleurs, styles). AppBarTheme personnalise spécifiquement la barre du haut. Ça garde un style cohérent partout.

\subsection*{15. Rôle de onPressed() et \{\}}
onPressed() définit ce qui se passe quand on clique. Les \{\} vides créent une fonction qui ne fait rien pour l'instant, mais le bouton reste cliquable.

\subsection*{16. À quoi sert showModalBottomSheet}
Ça ouvre une fenêtre qui remonte du bas de l'écran. Pratique pour les formulaires ou options sans changer de page complètement.

\subsection*{17. Pourquoi NewTask est StatefulWidget}
Parce qu'il gère un formulaire ! Il faut stocker ce que l'utilisateur tape, gérer la validation, les erreurs. Tout ça change pendant l'utilisation.

\subsection*{18. Rôle du contrôleur et dispose()}
Le TextEditingController me donne plus de contrôle sur mon champ de texte. Je peux lire la valeur, la modifier par code. dispose() libère la mémoire quand le widget disparaît pour éviter les fuites.

\subsection*{19. Meilleure méthode pour récupérer la saisie}
Je préfère le contrôleur. C'est plus performant car ça ne reconstruit pas le widget à chaque caractère tapé. Plus de contrôle aussi.

\vspace{1cm}
\rule{\textwidth}{0.5pt}

\section*{Conclusion}
Ce TP m'a appris les bases de Flutter. J'ai compris comment organiser le code, gérer l'état et créer une interface utilisateur. L'architecture avec les widgets séparés rend le code plus propre et maintenable.

Le code source complet est disponible sur GitHub : \url{https://github.com/YoussefLouzi/FLUTTER-TODOLIST}

\end{document}